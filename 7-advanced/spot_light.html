<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>点光源聚光灯阴影</title>
<style>
    body{margin: 0;}
</style>
</head>
<body>
<canvas id="canvas" width="600" height="450"></canvas>
<script src="../../graphics/webgl-util.js"></script>
<script src="../../graphics/matrix.js"></script>
<script src="../../graphics/util.js"></script>
<script src="../../graphics/polygon.js"></script>
<script type="x-shader/x-vertex" id="svs">
    attribute vec4 a_position; 
    uniform mat4 u_mvpMatrix; 
    void main() { 
        gl_Position = u_mvpMatrix * a_position; 
    }
</script>
<script type="x-shader/x-fragment" id="sfs">
    #ifdef GL_ES
        precision highp float;
    #endif
    vec4 pack (float depth) {
        // 使用rgba 4字节共32位来存储z值,1个字节精度为1/256
        const vec4 bitShift = vec4(1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0);
        const vec4 bitMask = vec4(1.0/256.0, 1.0/256.0, 1.0/256.0, 0.0);
        // gl_FragCoord:片元的坐标,fract():返回数值的小数部分
        vec4 rgbaDepth = fract(depth * bitShift); //计算每个点的z值 
        rgbaDepth -= rgbaDepth.gbaa * bitMask; // Cut off the value which do not fit in 8 bits
        return rgbaDepth;
    }
    //该片元着色器目的是计算每个片元的深度值z,并把z值保存到gl_FragColor中,可以把该纹理看成是深度值z的容器,因为它并不会渲染出来
    void main() {
        gl_FragColor = pack(gl_FragCoord.z);// 将z值分开存储到rgba分量中,阴影颜色的同时也是深度值z
    }
</script>
<script type="x-shader/x-vertex" id="vs">
    attribute vec4 a_position;
    attribute vec4 a_color;
    attribute vec4 a_normal;
    uniform mat4 u_modelMatrix;//等比例变换,可以用模型矩阵代替逆转置矩阵
    uniform mat4 u_mvpMatrix;//当前视点观测的模型视图投影矩阵
    uniform mat4 u_mvpMatrixFromLight;//光源处观察的模型视图投影矩阵
    uniform mat4 u_normalMatrix;
    varying vec4 v_positionFromLight;
    varying vec3 v_position;
    varying vec3 v_normal;
    varying vec4 v_color;
    void main() {
        gl_Position = u_mvpMatrix * a_position; // 当前视点观察到的坐标
        v_positionFromLight = u_mvpMatrixFromLight * a_position;//光源处观察到的坐标,用于后续分解出z值
        v_position = vec3(u_modelMatrix * a_position);//顶点在世界坐标系中的位置
        v_normal = normalize(vec3(u_normalMatrix * a_normal));
        v_color = a_color;
    }
</script>
<script type="x-shader/x-fragment" id="fs">
    #ifdef GL_ES
        precision highp float;
    #endif
    uniform vec3 u_lightColor;
    uniform vec3 u_lightPosition;
    uniform vec3 u_ambientColor;
    uniform vec3 u_viewPosition;
    uniform sampler2D u_shadowMap;

    varying vec4 v_positionFromLight;
    varying vec3 v_position;
    varying vec3 v_normal;
    varying vec4 v_color;

    /**
     * 释出深度值z
     */
    float unpack(const in vec4 rgbaDepth) {
        const vec4 bitShift = vec4(1.0, 1.0/256.0, 1.0/(256.0*256.0), 1.0/(256.0*256.0*256.0));
        return dot(rgbaDepth, bitShift);
    }
    // pcf消除阴影边缘的锯齿
    float pcf(float cosTheta,vec4 v_positionFromLight) {
        float shadows = 0.0;
        float opacity = 0.4;// 基底阴影alpha值
        float texelSize = 1.0/2048.0;// 阴影像素尺寸,值越小阴影越逼真
        vec4 rgbaDepth;
        // 将xyz坐标从齐次坐标区间[-1,1]归一化为纹理使用的[0,1]，xy分量用于查找纹理颜色值rgba，z分量就是在光源坐标系下的深度值; 
        vec3 shadowCoord = (v_positionFromLight.xyz/v_positionFromLight.w)/2.0 + 0.5;
        // 根据光线与表面的夹角计算偏移量,用于消除马赫带
        float bias = 0.005 * tan(acos(cosTheta));
        bias = clamp(bias, 0.0015, 0.01);

        for(float y=-1.5; y <= 1.5; y += 1.0){
            for(float x=-1.5; x <=1.5; x += 1.0){
                rgbaDepth = texture2D(u_shadowMap, shadowCoord.xy + vec2(x,y) * texelSize);
                shadows += step(shadowCoord.z - bias, unpack(rgbaDepth));
            }
        }
        shadows /= 16.0;
        return min(opacity + shadows, 1.0);
    }
    void main() {
        // 对法线归一化，因为其内插之后长度不一定是1
        vec3 normal = normalize(v_normal);
        // 点光源反向 光源位置-顶点位置
        vec3 lightDirection = normalize(u_lightPosition - v_position.xyz);
        // 光线方向和法向量的夹角，它们的点积即可求出夹角余弦值(范围0-90度)
        float cosTheta = max(dot(lightDirection, normal), 0.0);
        
        /*
        * 聚光灯
        */
        //默认照射方向是坐标原点(0,0,0),可通过指定照射角度(degX,degY,degZ)或者 照射坐标(x,y,z) 设置朝向
        float limit = cos(radians(25.0)) * cosTheta;//照射范围角度 * 背面消除
        //outerLimit和innerLimit之间的光线模糊效果
        float outerLimit = cos(radians(25.0));//模糊外径角度
        float innerLimit = cos(radians(20.0));//模糊内径角度
        vec3 lightPosition = normalize(u_lightPosition);
        float dotFromDirection = dot(lightDirection,lightPosition);
        float blurRange = smoothstep(outerLimit, innerLimit, dotFromDirection);//模糊范围

        float shininess = 50.0;
        vec3 specularColor = vec3(1.0,1.0,1.0);//镜面反射光颜色
        float specularWeighting = 0.0;
        vec3 diffuse = vec3(0.0,0.0,0.0);
        float visibility = 1.0;

        //计算光照范围内效果
        if (dotFromDirection >= limit) {
            // 漫反射
            diffuse = u_lightColor * v_color.rgb * blurRange * cosTheta;
            // 高光
            vec3 viewDirection = normalize(u_viewPosition-v_position.xyz);// 反射方向
            vec3 halfwayDir = normalize(lightDirection + viewDirection);
            specularWeighting = pow(max(dot(normal, halfwayDir), 0.0), shininess);
            //阴影
            visibility = pcf(cosTheta,v_positionFromLight);
        }
        
        // 环境光亮度
        vec3 ambient = u_ambientColor * v_color.rgb;
        // 镜面高光亮度
        vec3 specular = specularColor.rgb * specularWeighting * blurRange;
        gl_FragColor = vec4((diffuse + ambient + specular) * visibility, v_color.a);        
    }
</script>
<script>
// 阴影贴图是一种使用深度纹理来为渲染阴影提供解决方案的多通道计算。
// 它的关键是，就是用投射光源代替最终视口来观察场景。通过移动视口到光源位置，可以观察到这个位置每个东西都是明亮的，因为从光的角度来看是没有阴影的。
// 从光源的角度将场景的深度渲染到一张深度缓冲区中，我们可以在场景中获得一张阴影或者无阴影的贴图.

var canvas = document.getElementById('canvas'),
    gl = get3DContext(canvas),
    OFFSCREEN_WIDTH = 2048,
    OFFSCREEN_HEIGHT = 2048,
    viewAngleX=15,
    viewAngleY=15,
    cViewAngleX=0,
    cViewAngleY=0,
    viewLEN=12,
    LENPERCENT = 1,
    LIGHT_POS=[3,2.5,6],//光源位置
    CENTER = { x: canvas.width / 2, y: canvas.height / 2 },
    START = {};

function main() {
    if (!gl) {
        console.log('Failed to get the rendering context for WebGL');
        return;
    }

    // 初始化阴影着色器,创建对应program
    var shadowProgram = createProgramInfo(gl,['svs','sfs']);

    // 初始化普通着色器,创建对应program
    var normalProgram = createProgramInfo(gl,['vs','fs']);

    // 获取对应图形的缓冲区对象
    var planeBuffers = createBufferInfoFromArrays(gl,Plane());
    var cubeBuffers = createBufferInfoFromArrays(gl,Cube([0.8,0.2,0.3,1]));
    // var cubeBuffers = createBufferInfoFromArrays(gl,Cube([1,0,0,1]));

    // 初始化帧缓冲区对象 (FBO)  
    var fbo = createFramebuffer(gl,{ w: OFFSCREEN_WIDTH, h: OFFSCREEN_HEIGHT });
    if (!fbo) {
        console.log('Failed to initialize frame buffer object');
        return;
    }

    // 设置背景设并开启隐藏面消除功能 
    gl.clearColor(0, 0, 0, 1);
    gl.enable(gl.DEPTH_TEST);
    // gl.polygonOffset(1.0, 1.0)
    // gl.enable(gl.CULL_FACE);
    // gl.cullFace(gl.BACK);
    
    var viewProjMatrixFromLight = new Matrix4(); // 光源处观察的视图投影矩阵(阴影着色器)
    viewProjMatrixFromLight.setPerspective(90, OFFSCREEN_WIDTH / OFFSCREEN_HEIGHT, 1.0, 100.0);
    viewProjMatrixFromLight.lookAt(...LIGHT_POS, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0);

    var viewProjMatrix = new Matrix4(); // 当前视点观测的视图投影矩阵(正常着色器)
    var mvpMatrixFromLight_s = new Matrix4(); // 从光源处观察圆球的mvp矩阵(正常着色器)
    var mvpMatrixFromLight_c = new Matrix4(); // 从光源处观察立方体的mvp矩阵(正常着色器)
    var mvpMatrixFromLight_p = new Matrix4(); // 从光源处观察平面的mvp矩阵(正常着色器)
    var mvpMatrix = new Matrix4();// 通用mvp矩阵
    var modelMatrix = new Matrix4();// 模型矩阵(正常着色器)
    var normalMatrix = new Matrix4();// 向量矩阵

    var angle=29,ANGLE_STEP = 40, last = Date.now();
    (function animate(){
        var now = new Date(),
            elapsed = now - last;

        last = now;
        angle += ANGLE_STEP * elapsed / 1000;
        angle %= 360;

        var angleX=(viewAngleX+cViewAngleX)%360;
            angleY=viewAngleY+cViewAngleY,
            len=viewLEN*LENPERCENT;
        angleY=angleY>90?90:angleY<10?10:angleY;
        len=len>30?30:len<6?6:len;

        var eyeY=len*Math.sin(angleY*Math.PI/180),
            c=len*Math.cos(angleY*Math.PI/180),
            eyeX=c*Math.sin(angleX*Math.PI/180),
            eyeZ=c*Math.cos(angleX*Math.PI/180);

        viewProjMatrix.setPerspective(35, canvas.width / canvas.height, 1.0, 100.0);
        viewProjMatrix.lookAt(eyeX,eyeY,eyeZ, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0);
        gl.bindFramebuffer(gl.FRAMEBUFFER, fbo); // 切换绘制场景为帧缓冲区  
        gl.viewport(0, 0, OFFSCREEN_WIDTH, OFFSCREEN_HEIGHT); // 设置帧绘图区域
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT); // Clear FBO    
        /*
         * 阴影着色器
         */ 
        gl.useProgram(shadowProgram.program);
        
        // 绘制立方体
        drawCube(shadowProgram,viewProjMatrixFromLight);
                
        // 绘制平面
        drawPlane(shadowProgram,viewProjMatrixFromLight);
        
        // 将帧缓冲区切换为正常的缓冲区
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        gl.viewport(0, 0, canvas.width, canvas.height);//设置绘图区域
         // 清屏和深度缓冲
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
        
        /*
         * 正常的着色器
         */ 
        gl.useProgram(normalProgram.program);

        setUniforms(normalProgram,{
            u_shadowMap: 0, // 传递0号纹理:gl.TEXTURE0
            u_lightColor: [1,1,1],// 光照颜色
            u_lightPosition: LIGHT_POS, // 光线方向(世界坐标系下)
            u_ambientColor:[0.2,0.2,0.2], // 环境光颜色
            u_viewPosition:[eyeX,eyeY,eyeZ]
        });
        
        // 绘制立方体        
        drawCube(normalProgram,viewProjMatrix);
        // 绘制平面
        drawPlane(normalProgram,viewProjMatrix);
        
        requestAnimationFrame(animate);
    }());

    function drawCube(program,vpMatrix){
        modelMatrix.setTranslate( 1, 2, 2);
        modelMatrix.rotate(angle, 0, 1, 0);
        mvpMatrix.set(vpMatrix);
        mvpMatrix.multiply(modelMatrix);
        normalMatrix.setInverseOf(modelMatrix);
        normalMatrix.transpose();

        if(program==shadowProgram){
            mvpMatrixFromLight_c.set(mvpMatrix);
        } else {
            setUniforms(program,{
                u_mvpMatrixFromLight: mvpMatrixFromLight_c.elements,
                u_modelMatrix: modelMatrix.elements,
                u_normalMatrix: normalMatrix.elements
            });
        }
        draw(gl, program, cubeBuffers,mvpMatrix);
    }

    function drawPlane(program,vpMatrix){
        modelMatrix.setRotate(0, 1, 0, 0);
        modelMatrix.scale(4,4,4);
        mvpMatrix.set(vpMatrix);
        mvpMatrix.multiply(modelMatrix);
        if(program==shadowProgram){
            mvpMatrixFromLight_p.set(mvpMatrix);
        } else {
            setUniforms(program,{
                u_mvpMatrixFromLight: mvpMatrixFromLight_p.elements,
                u_modelMatrix: modelMatrix.elements
            });
        }
        draw(gl, program, planeBuffers,mvpMatrix);
    }
}


function draw(gl, program, buffer,mvpMatrix) {
    // 输出attribute对应的数据缓冲
    setBuffersAndAttributes(gl,program,buffer);
    setUniforms(program,{u_mvpMatrix: mvpMatrix.elements});
    gl.drawElements(gl.TRIANGLES, buffer.count, buffer.indexType, 0);
}

canvas.addEventListener('mousedown', function(e) {
    START = windowToCanvas(canvas, e.clientX, e.clientY);
    canvas.addEventListener('mousemove', mouseMove, false);
    canvas.addEventListener('mouseup', mouseUp, false);
    canvas.addEventListener('mouseout', mouseUp, false);
}, false);

function mouseMove(e) {
    var end = windowToCanvas(canvas, e.clientX, e.clientY),
        a = Math.sqrt(Math.pow(START.x - CENTER.x, 2) + Math.pow(START.y - CENTER.y, 2)),
        b = Math.sqrt(Math.pow(end.x - CENTER.x, 2) + Math.pow(end.y - CENTER.y, 2)),
        radX = (START.x - end.x) * 0.01,
        radY = (end.y - START.y) * 0.01;

    cViewAngleX = radX * 180 / Math.PI;
    cViewAngleY = radY * 180 / Math.PI;
    cViewAngleY > 90 ? 90 : cViewAngleY < -90 ? -90 : cViewAngleY;
    LENPERCENT = b / a;
}

function mouseUp(e) {
    viewAngleX += cViewAngleX;
    cViewAngleX = 0;
    viewAngleY += cViewAngleY;
    cViewAngleY = 0;
    viewLEN *= LENPERCENT;
    LENPERCENT = 1;
    canvas.removeEventListener('mouseup', arguments.callee, false);
    canvas.removeEventListener('mousemove', mouseMove, false);
    canvas.removeEventListener('mouseout', mouseUp, false);
}
main();
</script>
</body>
</html>
